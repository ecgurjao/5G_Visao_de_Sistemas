<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chapter 4: Radio Access Network &mdash; Private 5G: A Systems Approach Version 0.1-dev documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="shortcut icon" href="_static/bridge.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="https://www.googletagmanager.com/gtag/js?id=G-C4RNJ35K6B"></script>
        <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-C4RNJ35K6B');
</script>
    <script src="_static/js/theme.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 5: Mobile Core" href="core.html" />
    <link rel="prev" title="Chapter 3: Radio Transmission" href="radio.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Private 5G: A Systems Approach
          </a>
              <div class="version">
                Version 0.1-dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Pref?cio</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Chapter 2:  Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="radio.html">Chapter 3:  Radio Transmission</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 4:  Radio Access Network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#packet-processing-pipeline">4.1 Packet Processing Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#split-ran">4.2 Split RAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#software-defined-ran">4.3 Software-Defined RAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#near-real-time-ric">4.4 Near Real-Time RIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#control-loops">4.5 Control Loops</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="core.html">Chapter 5:  Mobile Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud.html">Chapter 6:  Managed Cloud Service</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About The Book</a></li>
<li class="toctree-l1"><a class="reference internal" href="authors.html">About The Authors</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Private 5G: A Systems Approach</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Chapter 4:  Radio Access Network</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ran.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="radio.html" class="btn btn-neutral float-left" title="Chapter 3: Radio Transmission" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="core.html" class="btn btn-neutral float-right" title="Chapter 5: Mobile Core" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="chapter-4-radio-access-network">
<h1>Chapter 4:  Radio Access Network<a class="headerlink" href="#chapter-4-radio-access-network" title="Permalink to this headline"></a></h1>
<p>The high-level description of the RAN in Chapter 2 was mostly silent
about the RAN’s internal structure. We now focus on those details, and
in doing so, explain how the RAN is being transformed in 5G.</p>
<p>You can think of the RAN as having one main job: to transfer packets
between the mobile core and a set of UEs. This means it is deeply
involved in the management and scheduling of radio spectrum that we
discussed in the last chapter, but there is more to it than that. We
start by describing the stages in the RAN’s packet processing
pipeline, and then showing how these stages are being disaggregated,
distributed, and implemented.</p>
<p>Note that the deconstruction of the RAN presented in this chapter
represents a combination of standardized specifications and
implementation strategies. The former continues to be under the
purview of the 3GPP, but the latter are primarily influenced by a
second organization: the <em>Open-RAN Alliance (O-RAN)</em> introduced in
Chapter 1. The O-RAN is led by network operators with the goal of
developing a software-based implementation of the RAN that breaks the
vendor lock-in.  Such business forces are certainly a factor in where
5G mobile networks are headed, but our goal in this chapter is to
identify the technical design decisions involved in that evolution.</p>
<section id="packet-processing-pipeline">
<h2>4.1 Packet Processing Pipeline<a class="headerlink" href="#packet-processing-pipeline" title="Permalink to this headline"></a></h2>
<p><a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a> shows the packet processing stages
historically bundled in base stations, as specified by the 3GPP
standard. Note that the figure depicts the base station as a pipeline
(running left-to-right for packets sent to the UE) but it is equally
valid to view it as a protocol stack (as is typically done in official
3GPP documents). Also note that (for now) we are agnostic as to how
these stages are implemented. Since we are ultimately heading
towards a cloud-based implementation, one possible implementation
strategy would be a microservice per box.</p>
<figure class="align-center" id="id5">
<span id="fig-pipeline"></span><a class="reference internal image-reference" href="_images/Slide110.png"><img alt="_images/Slide110.png" src="_images/Slide110.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 24. </span><span class="caption-text">RAN processing pipeline, including both user and
control plane components.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The key stages are as follows.</p>
<ul class="simple">
<li><p>RRC (Radio Resource Control) → Responsible for configuring the
coarse-grain and policy-related aspects of the pipeline. The RRC runs
in the RAN’s control plane; it does not process packets on the user
plane.</p></li>
<li><p>PDCP (Packet Data Convergence Protocol) → Responsible for compressing
and decompressing IP headers, ciphering and integrity protection, and
making an “early” forwarding decision (i.e., whether to send the
packet down the pipeline to the UE or forward it to another base
station).</p></li>
<li><p>RLC (Radio Link Control) → Responsible for segmentation and
reassembly, including reliably transmitting/receiving segments by
implementing a form of ARQ (automatic repeat request).</p></li>
<li><p>MAC (Media Access Control) → Responsible for buffering, multiplexing
and demultiplexing segments, including all real-time scheduling
decisions about what segments are transmitted when. Also able to make
a “late” forwarding decision (i.e., to alternative carrier
frequencies, including Wi-Fi).</p></li>
<li><p>PHY (Physical Layer) → Responsible for coding and modulation (as
discussed in Chapter 3), including FEC.</p></li>
</ul>
<p>The last two stages in <a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a> (D/A
conversion and the RF front-end) are beyond the scope of this book.</p>
<p>While it is simplest to view the stages in <a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a> as a pure left-to-right pipeline, the Scheduler
described in Section 3.2 (denoted “S” in the figure) runs in the MAC
stage, and implements the “main loop” for outbound traffic: It reads
data from the upstream RLC and schedules transmissions to the
downstream PHY.  Since the Scheduler determines the number of bytes to
transmit to a given UE during each time period (based on all the
factors outlined in Chapter 3), it must request (get) a segment of
that length from the upstream queue. In practice, the size of the
segment that can be transmitted on behalf of a single UE during a
single scheduling interval can range from a few bytes to an entire IP
packet.</p>
<p>Also note that a combination of the RRC and PDCP are responsible for
the observation made in Section 2.3: that a <em>“base station can be
viewed as a specialized forwarder”</em>. The control plane logic that
decides whether this base station should continue processing a packet
or forward it to another base station runs in the RRC, and the
corresponding data plane mechanism that carries out the forwarding
decision is implemented in the PDCP. The interface between these two
elements is defined by the 3GPP spec, but the decision-making logic is
an implementation choice (and historically proprietary). This control
logic is generically referred as the <em>Radio Resource Management
(RRM)</em>, not to be confused with the standards-defined RRC stage
depicted in <a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a>.</p>
</section>
<section id="split-ran">
<h2>4.2 Split RAN<a class="headerlink" href="#split-ran" title="Permalink to this headline"></a></h2>
<p>The next step is to understand how the functionality outlined above is
partitioned between physical elements, and hence, “split” across
centralized and distributed locations. The dominant option has
historically been “no split,” with the entire pipeline shown in
<a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a> running in the base station.  Going
forward, the 3GPP standard has been extended to allow for multiple
split-points, with the partition shown in <a class="reference internal" href="#fig-split-ran"><span class="std std-numref">Figure 25</span></a> being actively pursued by the operator-led O-RAN
Alliance. It is the split we adopt throughout the rest of this
book. Note that the split between centralized and distributed
components mirrors the split made in SDN, with similar motivations. We
discuss further how SDN techniques are applied to the RAN below.</p>
<figure class="align-center" id="id6">
<span id="fig-split-ran"></span><a class="reference internal image-reference" href="_images/Slide23.png"><img alt="_images/Slide23.png" src="_images/Slide23.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 25. </span><span class="caption-text">Split RAN processing pipeline distributed across a
Central Unit (CU), Distributed Unit (DU), and Radio Unit (RU).</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>This results in a RAN-wide configuration similar to that shown in
<a class="reference internal" href="#fig-ran-hierarchy"><span class="std std-numref">Figure 26</span></a>, where a single <em>Central Unit
(CU)</em> running in the cloud serves multiple <em>Distributed Units (DUs)</em>,
each of which in turn serves multiple <em>Radio Units (RUs)</em>. Critically,
the RRC (centralized in the CU) is responsible for making only
near-real-time configuration and control decisions, while the
Scheduler that is part of the MAC stage is responsible for all
real-time scheduling decisions.</p>
<figure class="align-center" id="id7">
<span id="fig-ran-hierarchy"></span><a class="reference internal image-reference" href="_images/Slide32.png"><img alt="_images/Slide32.png" src="_images/Slide32.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 26. </span><span class="caption-text">Split RAN hierarchy, with one CU serving multiple DUs,
each of which serves multiple RUs.</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Because scheduling decisions for radio transmission are made by the
MAC layer in real time, a DU needs to be “near” (within 1ms) the RUs
it manages. (You can’t afford to make scheduling decisions based on
out-of-date channel information.) One familiar configuration is to
co-locate a DU and an RU in a cell tower. But when an RU corresponds
to a small cell, many of which might be spread across a modestly-sized
geographic area (e.g., a mall, campus, or factory), then a single DU
would likely service multiple RUs. The use of mmWave in 5G is likely
to make this later configuration all the more common.</p>
<p>Also note that the Split RAN changes the nature of the Backhaul
Network, which originally connected the base stations back to the
Mobile Core.  With the Split RAN there are multiple connections, which
are officially labeled as follows.</p>
<ul class="simple">
<li><p>RU-DU connectivity is called the Fronthaul</p></li>
<li><p>DU-CU connectivity is called the Midhaul</p></li>
<li><p>CU-Mobile Core connectivity is called the Backhaul</p></li>
</ul>
<p>For more insight into design considerations for interconnecting the
distributed components of a Split RAN, we recommend the NGMN Alliance
Report.</p>
<div class="admonition-further-reading admonition" id="reading-backhaul">
<p class="admonition-title">Further Reading</p>
<p><a class="reference external" href="https://www.ngmn.org/wp-content/uploads/NGMN_RANEV_D4_BH_FH_Evolution_V1.01.pdf">RAN Evolution Project: Backhaul and Fronthaul Evolution</a>.
NGMN Alliance Report, March 2015.</p>
</div>
<p>One observation about the CU (which becomes relevant in Chapter 6 when
we incorporate it into a managed cloud service) is that one might
co-locate the CU and Mobile Core in the same cluster, meaning the
backhaul is implemented in the cluster switching fabric. In such a
configuration, the midhaul then effectively serves the same purpose as
the original backhaul, and the fronthaul is constrained by the
predictable/low-latency requirements of the MAC stage’s real-time
scheduler. This situation is further complicated by the fact that the
mobile core itself may be disaggregated, as discussed in Chapter 5.</p>
<p>A second observation about the CU shown in <a class="reference internal" href="#fig-split-ran"><span class="std std-numref">Figure 25</span></a> is that it encompasses two functional blocks—the RRC
and the PDCP—which lie on the RAN’s control plane and user plane,
respectively. This separation is consistent with the idea of CUPS
introduced in Chapter 2, and plays an increasingly important role as
we dig deeper into how the RAN is implemented. For now, we note that
the two parts are sometimes referred to as the CU-C and CU-U,
respectively.</p>
<p>We conclude our description of the split RAN architecture with the
alternative depiction in <a class="reference internal" href="#fig-split-alt"><span class="std std-numref">Figure 27</span></a>.
For completeness, this figure identifies the standardized interfaces between the
components (e.g., N2, N3, F1-U, F1-C, and Open Fronthaul). We’re not
going to talk about these interfaces, except to note that they exist
and there is a corresponding 3GPP specification that spells out the
details. Instead, we’re going to comment on the availability of open
source implementations for each component.</p>
<figure class="align-center" id="id8">
<span id="fig-split-alt"></span><a class="reference internal image-reference" href="_images/Slide101.png"><img alt="_images/Slide101.png" src="_images/Slide101.png" style="width: 150px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 27. </span><span class="caption-text">Alternative depiction of the Split RAN components, showing the
3GPP-specified inter-unit interfaces.</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>With respect to the Central Unit, most of the complexity is in the
CU-C, which, as we’ll see in the next section, is being re-engineered
using SDN, with open source solutions available.  With respect to the
Radio Unit, nearly all the complexity is in D/A conversion and how the
resulting analog signal is amplified. Incumbent vendors have
significant proprietary know-how in this space, which will almost
certainly remain closed.</p>
<p>With respect to the Distributed Unit, the news is mixed, and
correspondingly, the figure shows more detail. The High-PHY
module—which corresponds to all but the RF modulation step of
<a class="reference internal" href="radio.html#fig-modulation"><span class="std std-numref">Figure 17</span></a> in Section 3.1—is one of the most
complex components in the RAN stack. An open source implementation of
the High-PHY, known as FlexRAN, exists and is widely used in
commercial products. The only caveat is that the software license
restricts usage to Intel processors, although it is also the case that
the FlexRAN software exploits Intel-specific hardware capabilities. As
for the rest of the DU, the MAC is the other source of high-value
closed technology, particularly in how scheduling is done. There is an
open source version made available by the Open Air Initiative (OAI),
but its usage is restricted to research-only deployments.</p>
<div class="admonition-further-reading admonition" id="reading-du-impl">
<p class="admonition-title">Further Reading</p>
<p><a class="reference external" href="https://www.intel.com/content/www/us/en/developer/topic-technology/edge-5g/tools/flexran.html">FlexRAN: Reference Architecture for Wireless Access</a>.</p>
<p><a class="reference external" href="https://openairinterface.org/">Open Air Interface</a>.</p>
</div>
</section>
<section id="software-defined-ran">
<h2>4.3 Software-Defined RAN<a class="headerlink" href="#software-defined-ran" title="Permalink to this headline"></a></h2>
<p>We now describe how the RAN is being implemented according to SDN
principles, resulting in an SD-RAN. The key architectural insight is
shown in <a class="reference internal" href="#fig-rrc-split"><span class="std std-numref">Figure 28</span></a>, where the RRC from
<a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a> is partitioned into two
sub-components: the one on the left provides a 3GPP-compliant way for
the RAN to interface to the Mobile Core’s control plane (the figure
labels this sub-component as a “Proxy”), while the one on the right
opens a new programmatic API for exerting software-based control over
the pipeline that implements the RAN user plane.</p>
<p>To be more specific, the left sub-component simply forwards control
packets between the Mobile Core and the PDCP, providing a path over
which the Mobile Core can communicate with the UE for control
purposes, whereas the right sub-component implements the core of the
RRC’s control functionality (which as we explained in Section 4.1 is
also known as RRM). This latter component is commonly referred to as
the <em>RAN Intelligent Controller (RIC)</em> in O-RAN architecture
documents, so we adopt this terminology.  The “Near-Real Time”
qualifier indicates the RIC is part of 10-100ms control loop
implemented in the CU, as opposed to the ~1ms control loop required by
the MAC scheduler running in the DU.</p>
<figure class="align-center" id="id9">
<span id="fig-rrc-split"></span><a class="reference internal image-reference" href="_images/Slide42.png"><img alt="_images/Slide42.png" src="_images/Slide42.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 28. </span><span class="caption-text">RRC disaggregated into a Mobile Core facing control plane
component (a proxy) and a Near-Real-Time Controller.</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Although not shown in <a class="reference internal" href="#fig-rrc-split"><span class="std std-numref">Figure 28</span></a>, keep in
mind (from <a class="reference internal" href="#fig-split-ran"><span class="std std-numref">Figure 25</span></a>) that the RRC and the PDCP,
form the CU. Reconciling these two figures is a little bit messy, but
to a first approximation, the PDCP corresponds to the CU-U and
RRC-Proxy corresponds to the CU-C, with the RIC “lifted out” and
responsible for overseeing both.  We postpone a diagram depicting this
relationship until Section 4.5, where we summarize the end-to-end
result. For now, the important takeaway is that the SDN-inspired
refactoring of the RAN is free both to move functionality around and to
introduce new module boundaries, as long as the original 3GPP-defined
interfaces are preserved.</p>
<figure class="align-center" id="id10">
<span id="fig-ran-controller"></span><a class="reference internal image-reference" href="_images/Slide52.png"><img alt="_images/Slide52.png" src="_images/Slide52.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 29. </span><span class="caption-text">Example set of control applications (xApps) running on top of
Near-Real-Time RAN Controller (RIC), controlling a distributed set
of Split RAN elements (CU, DU, RU).</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Completing the picture, <a class="reference internal" href="#fig-ran-controller"><span class="std std-numref">Figure 29</span></a> shows
the Near-RT RIC implemented as an SDN Controller hosting a set of SDN
control apps. The RIC maintains a <em>RAN Network Information Base
(R-NIB)</em>—a common set of information that can be consumed by numerous
control apps. The R-NIB includes time-averaged CQI values and other
per-session state (e.g., GTP tunnel IDs, QCI values for the type of
traffic), while the MAC (as part of the DU) maintains the
instantaneous CQI values required by the real-time scheduler.  More
generally, the R-NIB includes the following state:</p>
<ul class="simple">
<li><p>Fixed Nodes (RU/DU/CU Attributes)</p>
<ul>
<li><p>Identifiers</p></li>
<li><p>Version</p></li>
<li><p>Config Report</p></li>
<li><p>RRM config</p></li>
<li><p>PHY resource usage</p></li>
</ul>
</li>
<li><p>Mobile Nodes (UE Attributes)</p>
<ul>
<li><p>Devices</p>
<ul>
<li><p>Identifiers</p></li>
<li><p>Capability</p></li>
<li><p>Measurement Config</p></li>
<li><p>State (Active/Idle)</p></li>
</ul>
</li>
<li><p>Links (<em>Actual</em>  and <em>Potential</em>)</p>
<ul>
<li><p>Identifiers</p></li>
<li><p>Link Type</p></li>
<li><p>Config/Bearer Parameters</p></li>
<li><p>QCI Value</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Virtual Constructs (Slice Attributes)</p>
<ul>
<li><p>Links</p></li>
<li><p>Bearers/Flows</p></li>
<li><p>Validity Period</p></li>
<li><p>Desired KPIs</p></li>
<li><p>MAC RRM Configuration</p></li>
<li><p>RRM Control Configuration</p></li>
</ul>
</li>
</ul>
<p>The four example Control Apps (xApps) in <a class="reference internal" href="#fig-ran-controller"><span class="std std-numref">Figure 29</span></a> do not constitute an exhaustive list, but they
do represent the sweet spot for SDN, with its emphasis on central
control over distributed forwarding. These functions—Link Aggregation
Control, Interference Management, Load Balancing, and Handover
Control—are often implemented by individual base stations with only
local visibility, but they have global consequences. The SDN approach
is to collect the available input data centrally, make a globally
optimal decision, and then push the respective control parameters back
to the base stations for execution. Evidence using an analogous
approach to optimize wide-area networks over many years (see for
example B4) is compelling.</p>
<div class="admonition-further-reading admonition" id="reading-b4">
<p class="admonition-title">Further Reading</p>
<p>For an example of how SDN principles have been successfully applied
to a production network, we recommend <a class="reference external" href="https://cseweb.ucsd.edu/~vahdat/papers/b4-sigcomm13.pdf">B4: Experience with a
Globally-Deployed Software Defined WAN</a>.  ACM
SIGCOMM, August 2013.</p>
</div>
<p>One way to characterize xApps is based on the current practice of
controlling the mobile link at two different levels. At a fine-grain
level, per-node and per-link control is conducted using the RRM
functions that are distributed across the individual base stations.<a class="footnote-reference brackets" href="#id2" id="id1">1</a>
RRM functions include scheduling, handover control, link and
carrier aggregation control, bearer control, and access control.  At a
coarse-grain level, regional mobile network optimization and
configuration is conducted using <em>Self-Organizing Network (SON)</em>
functions. These functions oversee neighbor lists, manage load
balancing, optimize coverage and capacity, aim for network-wide
interference mitigation, centrally configure parameters, and so on. As
a consequence of these two levels of control, it is not uncommon to
see reference to <em>RRM Applications</em> and <em>SON Applications</em>,
respectively, in O-RAN documents for SD-RAN. For example, the
Interference Management and Load Balancing xApps in <a class="reference internal" href="#fig-ran-controller"><span class="std std-numref">Figure 29</span></a> are SON Applications, while the other two xApps
are RRM Applications.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Pedantically, Radio Resource Management (RRM) is another name
for the collection of control functionality typically
implemented in the RRC stage of the RAN pipeline.</p>
</dd>
</dl>
<p>Keep in mind, however, that this characterization of xApps is based on
past (pre-SDN) implementations of the RAN. This is helpful as the
industry transitions to SD-RAN, but the situation is likely to change.
SDN is transforming the RAN, so new ways of controlling the
RAN—resulting in applications that do not fit neatly into the RRM vs SON
dichotomy—can be expected to emerge over time.</p>
</section>
<section id="near-real-time-ric">
<h2>4.4 Near Real-Time RIC<a class="headerlink" href="#near-real-time-ric" title="Permalink to this headline"></a></h2>
<p>Drilling down to the next level of detail, <a class="reference internal" href="#fig-ric"><span class="std std-numref">Figure 30</span></a> shows an exemplar implementation of a RIC based on a
retargeting of the Open Network OS (ONOS) for the SD-RAN use
case. ONOS (described in our SDN book) was originally designed to
support traditional wireline network switches using standard
interfaces (OpenFlow, P4Runtime, etc.). For the SD-RAN use case, the
ONOS-based RIC instead supports a set of RAN-specific north- and
south-facing interfaces, but internally takes advantage of the same
collection of subsystems (microservices) as in the wireline case.<a class="footnote-reference brackets" href="#id4" id="id3">2</a></p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Technically, the O-RAN definition of the RIC refers to the
combination of xApps and the underlying platform (in our case
ONOS), but we emphasize the distinction between the two, in keeping
with the SDN model of distinguishing between the Network OS
and the suite of Control Apps that run on it.</p>
</dd>
</dl>
<figure class="align-center" id="id11">
<span id="fig-ric"></span><a class="reference internal image-reference" href="_images/Slide62.png"><img alt="_images/Slide62.png" src="_images/Slide62.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 30. </span><span class="caption-text">O-RAN compliant RAN Intelligent Controller (RIC) built by adapting
and extending ONOS.</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Specifically, the ONOS-based RIC includes a Topology Service to keep
track of the fixed RAN infrastructure, a Device Service to track the
UEs, and a Configuration Service to manage RAN-wide configuration
state. All three of these services are implemented as Kubernetes-based
microservices, and take advantage of a scalable Key/Value Store.</p>
<p>Of the three interfaces called out in <a class="reference internal" href="#fig-ric"><span class="std std-numref">Figure 30</span></a>,
the <strong>A1</strong> and <strong>E2</strong> interfaces are based on pre-existing 3GPP
standards. The third, <strong>xApp SDK</strong>, is specific to the ONOS-based
implementation. The O-RAN Alliance is using it to drive towards a
unified API (and corresponding SDK) for building RIC-agnostic xApps.</p>
<p>The A1 interface provides a means for the mobile operator’s management
plane—typically called the <em>OSS/BSS (Operations Support System /
Business Support System)</em> in the Telco world—to configure the RAN.  We
briefly introduced the OSS/BSS in Section 2.5, but all you need to
know about it for our purposes is that such a component sits at the
top of all Telco software stacks. It is the source of all
configuration settings and business logic needed to operate a
network. You can think of A1 as the RAN’s counterpart to gNMI/gNOI
(gRPC Network Management Interface/gRPC Network Operations Interface),
a pair of configuration APIs commonly used to configure commodity
cloud hardware.</p>
<p>The Near-RT RIC uses the E2 interface to control the underlying RAN
elements, including the CU, DUs, and RUs. A requirement of the E2
interface is that it be able to connect the Near-RT RIC to different
types of RAN elements from different vendors. This range is reflected
in the API, which revolves around a <em>Service Model</em> abstraction. The
idea is that each RAN element advertises a Service Model, which
effectively defines the set of RAN Functions the element is able to
support. The RIC then issues a combination of the following four
operations against this Service Model.</p>
<ul class="simple">
<li><p><strong>Report:</strong> RIC asks the element to report a function-specific value setting.</p></li>
<li><p><strong>Insert:</strong> RIC instructs the element to activate a user plane function.</p></li>
<li><p><strong>Control:</strong> RIC instructs the element to activate a control plane function.</p></li>
<li><p><strong>Policy:</strong> RIC sets a policy parameter on one of the activated functions.</p></li>
</ul>
<p>Of course, it is the RAN element, through its published Service Model,
that defines the relevant set of functions that can be activated, the
variables that can be reported, and policies that can be set.  The
O-RAN community is working on two vendor-agnostic Service Models. The
first, called <em>Key Performance Measurement</em> (abbreviated <em>E2SM-KPM</em>),
specifies the metrics that can be retrieved from RAN elements. The
second, called <em>RAN Control</em> (abbreviated <em>E2SM-RC</em>), specifies
parameters that can be set to control RAN elements.</p>
<p>In simple terms, E2SM-KPM defines what values can be <em>read</em> and
E2SM-RC defines what values can be <em>written</em>. Because the available
values can be highly variable across all possible devices, we can
expect different vendors will support only a subset of the entire
collection. This will limit the “universality” the O-RAN was hoping to
achieve in an effort to break vendor lock-in, but that outcome is
familiar to network operators who have been dealing with divergent
<em>Management Information Bases (MIBs)</em> since the earliest days of the
Internet.</p>
<p>Finally, the xApp SDK, which is specific to the ONOS-based
implementation, is currently little more than a “pass through” of the
E2 interface. This implies the xApps are expected to be aware of the
available Service Models. One of the challenges the SDK has to deal
with is how data passed to/from the RAN elements is encoded. For
historical reasons, the E2 interface uses ASN.1 formatting, whereas
the ONOS-RIC internally uses gRPC and Protocol Buffers to communicate
between the set of microservices. The south-bound E2 interface in
<a class="reference internal" href="#fig-ric"><span class="std std-numref">Figure 30</span></a> translates between the two formats. The
SDK currently makes the gRPC-based API available to xApps.</p>
<div class="admonition-further-reading admonition" id="reading-onos">
<p class="admonition-title">Further Reading</p>
<p>To learn more about the details of ONOS and its interfaces, we
recommend the chapter in our SDN book that covers it in
depth. <a class="reference external" href="https://sdn.systemsapproach.org/onos.html">Software-Defined Networks: A Systems Approach. Chapter 6:
Network OS</a>.</p>
</div>
</section>
<section id="control-loops">
<h2>4.5 Control Loops<a class="headerlink" href="#control-loops" title="Permalink to this headline"></a></h2>
<p>We conclude this description of RAN internals by re-visiting the
sequence of steps involved in disaggregation, which, as the previous
three sections reveal, is being pursued in multiple tiers. In doing
so, we tie up several loose ends, and focus attention on the resulting
three control loops.</p>
<p>In the first tier of disaggregation, 3GPP defines multiple options for
how the RAN can be split and distributed, with the pipeline shown in
<a class="reference internal" href="#fig-pipeline"><span class="std std-numref">Figure 24</span></a> disaggregated into the
independently operating CU, DU, and RU components shown in
<a class="reference internal" href="#fig-disagg1"><span class="std std-numref">Figure 31</span></a>. The O-RAN Alliance has selected
specific disaggregation options from 3GPP and is developing open
interfaces between these components.</p>
<figure class="align-center" id="id12">
<span id="fig-disagg1"></span><a class="reference internal image-reference" href="_images/Slide72.png"><img alt="_images/Slide72.png" src="_images/Slide72.png" style="width: 450px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 31. </span><span class="caption-text">First tier of RAN disaggregation: Split RAN.</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The second tier of disaggregation focuses on the control/user plane
separation (CUPS) of the CU, resulting in the CU-U and CU-C shown in
<a class="reference internal" href="#fig-disagg2"><span class="std std-numref">Figure 32</span></a>. The control plane in question is
the 3GPP control plane, where the CU-U realizes a pipeline for user
traffic and the CU-C focuses on control message signaling between
Mobile Core and the disaggregated RAN components (as well as to the
UE).</p>
<figure class="align-center" id="id13">
<span id="fig-disagg2"></span><a class="reference internal image-reference" href="_images/Slide82.png"><img alt="_images/Slide82.png" src="_images/Slide82.png" style="width: 450px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 32. </span><span class="caption-text">Second tier of RAN disaggregation: CUPS.</span><a class="headerlink" href="#id13" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The third tier follows the SDN paradigm by separating most of RAN
control (RRC functions) from the disaggregated RAN components, and
logically centralizing them as applications running on an SDN
Controller, which corresponds to the Near-RT RIC shown previously in
<a class="reference internal" href="#fig-rrc-split"><span class="std std-numref">Figures 28</span></a> and <a class="reference internal" href="#fig-ran-controller"><span class="std std-numref">29</span></a>. This SDN-based disaggregation is repeated in
<a class="reference internal" href="#fig-ctl-loops"><span class="std std-numref">Figure 33</span></a>, which also shows the O-RAN
prescribed interfaces A1 and E2 introduced in the previous section.
(Note that all the edges in <a class="reference internal" href="#fig-disagg1"><span class="std std-numref">Figures 31</span></a> and
<a class="reference internal" href="#fig-disagg2"><span class="std std-numref">32</span></a> correspond to 3GPP-defined interfaces, as
identified in Section 4.2, but their details are outside the scope of
this discussion.)</p>
<figure class="align-center" id="id14">
<span id="fig-ctl-loops"></span><a class="reference internal image-reference" href="_images/Slide92.png"><img alt="_images/Slide92.png" src="_images/Slide92.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Figure 33. </span><span class="caption-text">Third tier of RAN disaggregation: SDN.</span><a class="headerlink" href="#id14" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Taken together, the A1 and E2 interfaces complete two of the three
major control loops of the RAN: the outer (non-real-time) loop has the
Non-RT RIC as its control point and the middle (near-real-time) loop
has the Near-RT RIC as its control point. The third (innermost)
control loop—shown in <a class="reference internal" href="#fig-ctl-loops"><span class="std std-numref">Figure 33</span></a> running
inside the DU—includes the real-time Scheduler embedded in the MAC
stage of the RAN pipeline. The two outer control loops have rough time
bounds of &gt;&gt;1sec and &gt;10ms, respectively, and as we saw in Chapter 2,
the real-time control loop is assumed to be &lt;1ms.</p>
<p>This raises the question of how specific functionality is distributed
between the Non-RT RIC, Near-RT RIC, and DU. Starting with the second
pair (i.e., the two inner loops), it is the case that not all RRC
functions can be centralized; some need to be implemented in the
DU. The SDN-based disaggregation then focuses on those that can be
centralized, with the Near-RT RIC supporting the RRC applications and
the SON applications mentioned in Section 4.3.</p>
<p>Turning to the outer two control loops, the Near RT-RIC opens the
possibility of introducing policy-based RAN control, whereby
interrupts (exceptions) to operator-defined policies would signal the
need for the outer loop to become involved. For example, one can
imagine developing learning-based controls, where the inference
engines for these controls would run as applications on the Near
RT-RIC, and their non-real-time learning counterparts would run
elsewhere. The Non-RT RIC would then interact with the Near-RT RIC to
deliver relevant operator policies from the Management Plane to the
Near RT-RIC over the A1 interface.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="radio.html" class="btn btn-neutral float-left" title="Chapter 3: Radio Transmission" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="core.html" class="btn btn-neutral float-right" title="Chapter 5: Mobile Core" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Systems Approach LLC (Publisher).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>